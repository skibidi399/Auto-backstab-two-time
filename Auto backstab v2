local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local lp = Players.LocalPlayer

-- GUI Setup
local screenGui = Instance.new("ScreenGui")
screenGui.Name = "BackstabToggleGui"
screenGui.ResetOnSpawn = false
screenGui.Parent = lp:WaitForChild("PlayerGui")

-- Toggle Button
local toggleButton = Instance.new("TextButton")
toggleButton.Size = UDim2.new(0, 150, 0, 40)
toggleButton.Position = UDim2.new(0, 10, 0, 10)
toggleButton.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
toggleButton.TextColor3 = Color3.fromRGB(255, 255, 255)
toggleButton.Font = Enum.Font.SourceSansBold
toggleButton.TextSize = 20
toggleButton.Text = "Backstab: OFF"
toggleButton.Parent = screenGui

-- Range Label
local rangeLabel = Instance.new("TextLabel")
rangeLabel.Size = UDim2.new(0, 150, 0, 20)
rangeLabel.Position = UDim2.new(0, 10, 0, 55)
rangeLabel.BackgroundTransparency = 1
rangeLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
rangeLabel.Font = Enum.Font.SourceSans
rangeLabel.TextSize = 16
rangeLabel.Text = "Range:"
rangeLabel.Parent = screenGui

-- TextBox for Range Input
local rangeBox = Instance.new("TextBox")
rangeBox.Size = UDim2.new(0, 150, 0, 25)
rangeBox.Position = UDim2.new(0, 10, 0, 75)
rangeBox.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
rangeBox.TextColor3 = Color3.fromRGB(255, 255, 255)
rangeBox.Font = Enum.Font.SourceSans
rangeBox.TextSize = 16
rangeBox.PlaceholderText = "Enter range (number)"
rangeBox.Text = "4"
rangeBox.ClearTextOnFocus = false
rangeBox.Parent = screenGui

-- Vars
local enabled = false
local cooldown = false
local lastTarget = nil
local range = 4
local daggerRemote = ReplicatedStorage:WaitForChild("Modules"):WaitForChild("Network"):WaitForChild("RemoteEvent")
local killerNames = { "Jason", "c00lkidd", "JohnDoe", "1x1x1x1", "Noli" }
local killersFolder = workspace:WaitForChild("Players"):WaitForChild("Killers")

-- GUI toggle
toggleButton.MouseButton1Click:Connect(function()
	enabled = not enabled
	toggleButton.Text = "Backstab: " .. (enabled and "ON" or "OFF")
	toggleButton.BackgroundColor3 = enabled and Color3.fromRGB(50, 150, 50) or Color3.fromRGB(30, 30, 30)
end)

-- TextBox Range Handling
rangeBox.FocusLost:Connect(function()
    local input = tonumber(rangeBox.Text)
    if input and input >= 1 then
        range = input
    else
        rangeBox.Text = tostring(range) -- revert if invalid
    end
end)

-- Mode Toggle
local mode = "Behind"
local modeButton = Instance.new("TextButton")
modeButton.Size = UDim2.new(0, 150, 0, 25)
modeButton.Position = UDim2.new(0, 10, 0, 105)
modeButton.BackgroundColor3 = Color3.fromRGB(70, 70, 70)
modeButton.TextColor3 = Color3.fromRGB(255, 255, 255)
modeButton.Font = Enum.Font.SourceSans
modeButton.TextSize = 16
modeButton.Text = "Mode: Behind"
modeButton.Parent = screenGui

modeButton.MouseButton1Click:Connect(function()
	if mode == "Behind" then
		mode = "Around"
	else
		mode = "Behind"
	end
	modeButton.Text = "Mode: " .. mode
end)

-- Modified helper function
local function isBehindTarget(hrp, targetHRP)
	local distance = (hrp.Position - targetHRP.Position).Magnitude
	if distance > range then
		return false
	end
	
	if mode == "Around" then
		return true
	else
		local direction = -targetHRP.CFrame.LookVector
		local toPlayer = (hrp.Position - targetHRP.Position)
		return toPlayer:Dot(direction) > 0.5
	end
end

-- Main loop (ping-safe, strafing-safe, handles stopped killers)
RunService.Heartbeat:Connect(function()
	if not enabled or cooldown then return end

	local char = lp.Character
	if not (char and char:FindFirstChild("HumanoidRootPart")) then return end
	local hrp = char.HumanoidRootPart
	local stats = game:GetService("Stats")

	for _, name in ipairs(killerNames) do
		local killer = killersFolder:FindFirstChild(name)
		if killer and killer:FindFirstChild("HumanoidRootPart") then
			local kHRP = killer.HumanoidRootPart

			if isBehindTarget(hrp, kHRP) and killer ~= lastTarget then
				cooldown = true
				lastTarget = killer

				local start = tick()
				local didDagger = false
				local connection
				connection = RunService.Heartbeat:Connect(function()
					if not (char and char.Parent and kHRP and kHRP.Parent) then
						if connection then connection:Disconnect() end
						return
					end

					local elapsed = tick() - start
					if elapsed >= 0.5 then
						if connection then connection:Disconnect() end
						return
					end

					-- LIVE Ping + velocity prediction
					local ping = tonumber(stats.Network.ServerStatsItem["Data Ping"]:GetValueString():match("%d+")) or 50
					local pingSeconds = ping / 1000

					-- predicted position using velocity (simple linear prediction)
					local predictedPos = kHRP.Position + (kHRP.Velocity * pingSeconds)

					-- BACK OFFSET: base + ping-scaled portion
					-- base ensures a minimum behind distance even if target stops
					local baseBack = 0.3
					local pingScale = 4 -- studs per second of pingSeconds (tweakable)
					local pingBack = math.clamp(pingSeconds * pingScale, 0, 3) -- avoid huge offsets
					local backOffset = baseBack + pingBack

					-- Choose target position depending on mode
					local targetPos
					if mode == "Behind" then
						-- Always offset behind using LookVector (strafing-safe)
						targetPos = predictedPos - (kHRP.CFrame.LookVector * backOffset)
					elseif mode == "Around" then
						-- Keep your current relative bearing if it's meaningful,
						-- otherwise fallback to a safe behind position.
						local rel = hrp.Position - kHRP.Position
						if rel.Magnitude > 0.5 then
							-- preserve circle radius but clamp it so it's not too tiny or huge
							local radius = math.clamp(rel.Magnitude, 0.3, math.max(range, 3))
							targetPos = predictedPos + rel.Unit * radius
						else
							-- fallback to behind so we don't accidentally appear in front
							targetPos = predictedPos - (kHRP.CFrame.LookVector * backOffset)
						end
					else
						-- default safety
						targetPos = predictedPos - (kHRP.CFrame.LookVector * backOffset)
					end

					-- Constant live TP (heartbeat)
					hrp.CFrame = CFrame.new(targetPos, targetPos + kHRP.CFrame.LookVector)

					-- Only dagger once (but keep live-aligning)
					if not didDagger then
						didDagger = true

						-- Keep aligning for 0.7s with live ping/velocity recalculation
						local faceStart = tick()
						local faceConn
						faceConn = RunService.Heartbeat:Connect(function()
							if tick() - faceStart >= 0.7 or not kHRP or not kHRP.Parent then
								if faceConn then faceConn:Disconnect() end
								return
							end

							local livePing = tonumber(stats.Network.ServerStatsItem["Data Ping"]:GetValueString():match("%d+")) or 50
							local livePingSeconds = livePing / 1000
							local livePredictedPos = kHRP.Position + (kHRP.Velocity * livePingSeconds)

							local liveBaseBack = 0.3
							local livePingBack = math.clamp(livePingSeconds * pingScale, 0, 3)
							local liveBackOffset = liveBaseBack + livePingBack

							local liveTargetPos
							if mode == "Behind" then
								liveTargetPos = livePredictedPos - (kHRP.CFrame.LookVector * liveBackOffset)
							elseif mode == "Around" then
								local liveRel = hrp.Position - kHRP.Position
								if liveRel.Magnitude > 0.5 then
									local liveRadius = math.clamp(liveRel.Magnitude, 0.3, math.max(range, 3))
									liveTargetPos = livePredictedPos + liveRel.Unit * liveRadius
								else
									liveTargetPos = livePredictedPos - (kHRP.CFrame.LookVector * liveBackOffset)
								end
							else
								liveTargetPos = livePredictedPos - (kHRP.CFrame.LookVector * liveBackOffset)
							end
							hrp.CFrame = CFrame.new(liveTargetPos, liveTargetPos + kHRP.CFrame.LookVector)
						end)
						daggerRemote:FireServer("UseActorAbility", "Dagger")
					end
				end)

				-- Reset cooldown when out of range
				task.delay(2, function()
					RunService.Heartbeat:Wait()
					while isBehindTarget(hrp, kHRP) do
						RunService.Heartbeat:Wait()
					end
					lastTarget = nil
					cooldown = false
				end)

				break
			end
		end
	end
end)
